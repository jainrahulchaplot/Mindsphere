# Global Coding Instructions for MindSphere

## 0) Purpose & Scope

These instructions define how we plan, design, implement, test, and ship code across our **separated microservices architecture** with cleanliness, performance, observability, and safety. They also define Demo vs Production behavior and how we use MCP tools to ground decisions.

**Architecture Context:**
- `mindsphere-backend` - Node.js API server (Railway)
- `mindsphere-frontend` - React web app (Vercel)  
- `mindsphere-ai-agent` - LiveKit voice agent (Railway)
- `mindsphere-mobile` - React Native app (Expo)

## 1) Non-Negotiables (must follow)

- **Plan first, then code.** Never start coding before a written plan (template in §3).
- **Service-first thinking.** Always consider which service(s) are affected and their interactions.
- **Enhancement before new.** Prefer improving existing code unless the Decision Matrix (§4) justifies a new module.
- **No secrets in code.** All credentials/URLs/tokens via environment variables; validate at runtime and redact in logs.
- **Structured logging only.** Do not commit console.*. Use a structured logger pattern and include request/user context where available.
- **Performance budget minded.** Don't add caches/indexes/bulk deps without quick measurements proving benefit.
- **Cross-service testing.** Every PR that affects multiple services must include integration tests.
- **MCP-assisted evidence.** Use installed MCP tools to gather facts; include short summaries in your plan/PR (§2, §3).

## 2) MCP Tooling — what we use & when (installed set only)

- **Context7** → Gather official docs/links for APIs/SDKs you touch. Add 2–3 links you used in the plan. Never paste sample keys.
- **Supabase MCP Server** → For any DB change: inspect schema impact, run EXPLAIN/plan checks for your main queries, and summarize results.
- **chrome-devtools** → For UI changes: headless navigation to the changed path; capture console errors and a basic timing snapshot.
- **Cloudflare Playwright** → Add/update smoke tests for critical flows (auth, core flows, voice/join path if applicable); attach pass/fail summary.

**Tip:** If any MCP shows a red dot in Cursor, open its logs to fix missing env/config before proceeding.

## 3) Plan-First Template (paste in PR/issue before coding)

**Do not write code until this section is filled.**

### 1) Problem & intent
One paragraph in plain language.

### 2) Assumptions & constraints
Bullets (e.g., latency targets, compliance limits, browser/device limits).

### 3) Impact analysis
- **Affected services:** which microservices are touched?
- **Service boundaries:** which APIs/contracts change between services?
- **User flows:** which journeys change across services?
- **Database tables/indexes:** which read/write paths and indexes?
- **Env keys:** any new or changed environment variables across services?
- **Security & privacy:** data exposure, permissions, PII handling.
- **Performance:** expected latency/memory/bundle impact per service.
- **Deployment impact:** which services need redeployment?

### 4) Evidence via MCP (installed tools only)
- **Context7:** links used (2–3) → …
- **Supabase MCP:** schema notes & EXPLAIN snippets (short) → …
- **chrome-devtools:** headless check results (errors? basic timings?) → …
- **Cloudflare Playwright:** smoke run summary (route/flow + pass/fail) → …

### 5) Options (≥2) with pros/cons
Keep it brief. Note trade-offs, especially cross-service implications.

### 6) Chosen approach & why
Reference the Decision Matrix (§4).

### 7) Acceptance criteria
Functional + non-functional (perf, reliability, security) per affected service.

### 8) Test plan
Unit, integration/e2e, and any perf checks to run. Include cross-service tests.

### 9) Rollback plan
Feature flag or simple revert path. State data migration rollback if any. Include service-specific rollback steps.

## 4) Enhance vs New — Decision Matrix

**Choose Enhance existing when ≥2 hold:**
- Existing code covers ≥70% of the use case
- Public contracts/schemas remain stable
- Performance targets can be met with local optimization
- Changes are contained within a single service

**Choose New module/service when ≥2 hold:**
- Coupling would increase complexity significantly
- Existing path would breach SLOs (e.g., clear p95 regression)
- Data model/contract diverges (needs a separate read/write path)
- Changes span multiple services with different deployment cycles

**PRs must state the choice and cite at least two criteria.**

## 5) Service Architecture Guidelines

### Service Boundaries
- **Backend**: Data persistence, business logic, external API integrations
- **Frontend**: User interface, client-side state, user interactions
- **AI Agent**: Voice processing, real-time AI conversations, session management
- **Mobile**: Native features, offline capabilities, device integration

### Inter-Service Communication
- Use REST APIs for synchronous communication
- Use webhooks/events for asynchronous communication
- Implement circuit breakers for external service calls
- Always include request/response logging with correlation IDs

### Data Flow Principles
- Backend owns all data persistence
- Frontend/AI Agent/Mobile are stateless clients
- Use Supabase for real-time subscriptions
- Implement proper data validation at service boundaries

## 6) Error Handling & Observability

### Centralized Error Management
- Use a central error mapping so each failure returns a consistent structure and status code
- Include service name, correlation ID, and timestamp in all errors
- Implement proper error propagation across service boundaries
- Never use fallback data - fail fast with clear error messages

### Structured Logging (Enhanced)
- Structured logs only; include contextual fields where available (request id, user id, feature, service, duration, environment)
- Redact authorization, tokens, passwords, and PII
- Full stack traces only outside production; keep logs APM-friendly
- Use consistent log format across all services
- Include error severity levels: FATAL, ERROR, WARN, INFO, DEBUG
- Log all external service calls with response times and status codes
- Include request/response payloads for debugging (redacted in production)

### Error Logging Standards
```javascript
// Good error logging example
logger.error('Database connection failed', {
  service: 'mindsphere-backend',
  operation: 'user_authentication',
  userId: userId,
  correlationId: req.correlationId,
  error: error.message,
  stack: process.env.NODE_ENV === 'development' ? error.stack : undefined,
  timestamp: new Date().toISOString(),
  environment: process.env.NODE_ENV
});
```

### Monitoring & Alerting
- Each service should expose health check endpoints
- Implement distributed tracing for cross-service requests
- Set up alerts for service-specific and cross-service failures
- Monitor error rates, response times, and external service health

## 7) Performance & Reliability

### Service-Specific Performance
- Define (and note in the plan) the target latency for changed paths per service
- Measure before/after when touching hot paths; include a 1-line summary in the PR
- Add caches or indexes only with quick proof (numbers from a local/proxy load or DB EXPLAIN)
- Keep dependencies lean; justify heavy libs in the plan

### Cross-Service Performance
- Implement proper timeout handling for inter-service calls
- Use connection pooling for database connections
- Implement retry logic with exponential backoff
- Monitor and alert on service-to-service latency

## 8) Database & Migrations (MCP-checked)

### Backend Service Only
- Use forward-only migrations with a tested rollback script or revert plan
- Create/verify indexes before merging query changes that rely on them
- For any query change, run Supabase MCP to examine schema impacts and EXPLAIN typical queries; paste a short summary in the PR
- Respect RLS/permissions/policies where applicable

### Other Services
- Frontend/AI Agent/Mobile should never directly access the database
- Use Backend API for all data operations
- Implement proper data validation and sanitization

## 9) Security & External Services

### Secrets Management
- Secrets/tokens remain server-side; clients never hold long-lived credentials
- Use different secrets for different environments
- Implement secret rotation policies
- Use least-privilege permissions

### API Security
- Implement proper authentication/authorization at service boundaries
- Use HTTPS for all inter-service communication
- Implement rate limiting per service
- Validate all inputs at service boundaries

### External Service Integration
- Prefer short-lived tokens and least-privilege permissions
- Implement proper error handling for external service failures
- Use circuit breakers for external service calls
- Monitor external service health and performance

## 10) Testing Standard

### Service-Specific Testing
- Unit tests for new logic branches and bug fixes (add a regression test)
- Integration tests for service-specific functionality
- UI sanity via chrome-devtools headless checks to catch console errors and obvious regressions

### Cross-Service Testing
- Integration/e2e via Cloudflare Playwright for critical flows; include run summary
- Test service-to-service communication
- Test error propagation across services
- Test deployment and rollback scenarios

### Test Data Management
- Use separate test databases for each service
- Implement proper test data cleanup
- Use real service integrations in tests (no mocking)
- Test with actual external service responses

## 11) Git Repository Management

### Multi-Repository Structure
- **mindsphere-backend**: `https://github.com/yourusername/mindsphere-backend`
- **mindsphere-frontend**: `https://github.com/yourusername/mindsphere-frontend`
- **mindsphere-ai-agent**: `https://github.com/yourusername/mindsphere-ai-agent`
- **mindsphere-mobile**: `https://github.com/yourusername/mindsphere-mobile`

### Git Workflow Rules
- **One service per repository** - never mix service code
- **Feature branches** for all changes: `feature/description` or `fix/description`
- **Conventional commits**: `feat:`, `fix:`, `docs:`, `refactor:`, `test:`, `chore:`
- **Pull requests required** for all changes to main branch
- **Squash and merge** for clean history

### Repository-Specific Commands
```bash
# Backend changes
cd mindsphere-backend
git add .
git commit -m "feat: add user authentication endpoint"
git push origin feature/user-auth

# Frontend changes  
cd ../mindsphere-frontend
git add .
git commit -m "feat: add voice interface component"
git push origin feature/voice-interface

# AI Agent changes
cd ../mindsphere-ai-agent
git add .
git commit -m "fix: improve voice processing latency"
git push origin fix/voice-latency

# Mobile changes
cd ../mindsphere-mobile
git add .
git commit -m "feat: add offline mode support"
git push origin feature/offline-mode
```

### Cross-Service Changes
- **Document which services are affected** in commit messages
- **Update API contracts** in both services simultaneously
- **Coordinate deployments** across affected services
- **Use correlation IDs** to track changes across services

### Environment-Specific Branches
- **main**: Production-ready code
- **develop**: Integration branch for demo environment
- **feature/***: Feature development
- **hotfix/***: Critical production fixes

### Git Hooks & Automation
- **Pre-commit hooks**: Lint, format, and basic tests
- **Pre-push hooks**: Run full test suite
- **Commit message validation**: Enforce conventional commits
- **Branch protection**: Require PR reviews for main branch

### Repository Setup Checklist
- [ ] Initialize each service as separate Git repository
- [ ] Set up remote origins for each service
- [ ] Configure branch protection rules
- [ ] Set up pre-commit hooks
- [ ] Configure CI/CD pipelines per service
- [ ] Set up cross-service dependency tracking

## 12) Deployment & CI/CD

### Service-Specific Deployment
- Each service has its own deployment pipeline
- Use feature flags for gradual rollouts
- Implement proper health checks before marking services as healthy
- Use blue-green deployments for zero-downtime deployments

### Cross-Service Deployment
- Coordinate deployments that affect multiple services
- Use dependency management to ensure proper deployment order
- Implement proper rollback procedures for cross-service changes
- Monitor service dependencies and health

### Environment Management
- Use consistent environment variables across services
- Implement proper secret management per environment
- Use infrastructure as code for consistent deployments
- Monitor and alert on environment-specific issues

## 13) Demo vs Production Segregation

### Goals
- **Demo:** speed of iteration, relaxed guards, verbose diagnostics, safe sample data.
- **Production:** security, stability, performance, observability.

### Configuration Rules
- Use a single APP_ENV (or equivalent) with at least two values: demo, production.
- Secrets & endpoints must differ per environment (separate keys/URLs).
- Use different Supabase projects for demo and production.

### Logging:
- **Demo** → verbose logs and inline diagnostics are allowed; stack traces enabled.
- **Production** → info/warn/error only; stack traces gated; strict redaction enforced.

### Feature flags: unstable or experimental features are demo-only until validated.

### Data & privacy:
- Demo uses real data with limited scopes and enhanced logging.
- Production enforces full privacy, consent, and minimization rules.
- No mock or fallback data in any environment - use real services or fail fast.

### Rate limits & timeouts: relaxed in demo (for testing), stricter in prod (to protect SLOs).

### Observability:
- Demo may skip central APM if noisy; local logs suffice.
- Production requires consistent structured logs and alert paths for critical errors.

### Deployment:
- Demo may allow direct promotion after passing smoke tests.
- Production requires all PR quality gates, MCP summaries, and—if risk is high—progressive rollout or canary.

### Checklist to include in every plan when environment is relevant
- Which environment(s) does this change touch?
- Are env keys or scopes different between demo and prod?
- Any data exposure risk changes between environments?
- Is there a demo-only flag or override that must be removed before prod?

## 14) Definition of Done (DOD)

A change is Done only if all apply:

- MCP-assisted Plan is present; acceptance criteria met.
- Decision Matrix recorded; enhancement vs new justified.
- No secrets in code; env validated; structured logs & central error handling observed.
- Tests added/updated (or a short-term test plan with owner/date); smoke checks summarized.
- Performance note added for hot paths; DB EXPLAIN summary included if queries changed.
- Demo vs Production implications reviewed and configured correctly.
- Rollback/flag strategy documented.
- Changelog/docs updated when user-visible.
- Cross-service impact assessed and tested if applicable.

## 15) Service-Specific Guidelines

### Backend Service
- All database operations must go through this service
- Implement proper API versioning
- Use proper HTTP status codes
- Implement proper error handling and logging
- Use connection pooling for database connections

### Frontend Service
- Implement proper error boundaries
- Use proper loading states
- Implement proper form validation
- Use proper state management
- Implement proper accessibility features

### AI Agent Service
- Implement proper voice processing error handling
- Use proper session management
- Implement proper conversation state management
- Use proper audio quality optimization
- Implement proper fallback mechanisms

### Mobile Service
- Implement proper offline capabilities
- Use proper native feature integration
- Implement proper push notification handling
- Use proper device-specific optimizations
- Implement proper app state management

16) Always update all readme files after every update. And never create multiple readme or md files. keep all things in readme files at appropriate folder levels.

## Copy-me Footer (optional to keep at the end of PRs)

*I followed MindSphere Global Coding Instructions: planned first, used installed MCPs for evidence (Context7 / Supabase MCP / chrome-devtools / Cloudflare Playwright), applied the Decision Matrix, met the PR gates, and documented demo vs prod differences with a rollback path. Cross-service impact was assessed and tested.*